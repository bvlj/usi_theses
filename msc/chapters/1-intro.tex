%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}\label{sec:intro}

\begin{chapterBody}

Expressions are a combination of values (constants, functions \ldots) and
operators that can yield new values.
It is possible to combine expressions to make more complex expressions by
following the syntax and the semantics of a programming language.

The importance of expressions in non–functional programming languages should
not be  underestimated.
\citet{chiodini_expressions_2022} have shown that, for instance, expressions
constitute an essential part of programs written in the Java programming
language, although textbooks tend to prefer to emphasize other concepts and
gloss over expressions, presenting them only in context of other language
constructs such as conditionals.

Understanding how expressions work and how to evaluate them is fundamental if
one wants to be able to write more complex programs and reason about them in a
sound and systematic way.
This is particularly important in introductory Computer Science courses, where
students approach programming for the first time. Code comprehension is an
important skill to acquire and is considered important for a positive learning
outcome~\cite{donaldson_flexible_2018}.

Students often struggle at understanding their code, due to it originating from
variations of textbook examples and code snippets found online.
With the raise in capabilities and popularity of large language 
models (LLM), able to generate code from a user–supplied prompt, this problem
becomes more and more relevant.
The bar for \textit{producing code} lowers even more.
Empowering people with such tools has the consequence of decreasing one's 
comprehension of \textit{their own} code, as less thought is put into the
actual implementation details. Moreover, the code generated by these
\textit{code generators}, has no guarantee of being \textit{correct}.
This means that code comprehension becomes an even more critical skill to
acquire.
Code that is not understood nor properly reasoned about in the context in which 
it is supposed to live, is going to decrease the quality of code–bases and
increase their maintenance costs in the long run.

To help people gain better abilities at reasoning about and understanding code,
with a particular focus on expressions, many notional machines have been
developed~\cite{fincher_notional_2020}. Notional machines
are ``pedagogic devices used to assist the understanding of some aspect of
programs or programming''~\cite{fincher_notional_2020}.

Expression Tutor~\cite{matthias_hauswirth_expression_2023}, developed by the
\textit{Lugano Computing Education research lab} is a platform built around the 
goal of teaching expressions through the use of the ``Expression as Trees''
notional machine.
Expression trees offer a simple way to visualize how expressions may be
constructed through composition and to reason about combination and evaluation.

The Expression Tutor platform offers various resources to learn expressions:
from reference pages that showcase how different language constructs are
represented in the form of expression trees, to interactive pages in which one
may construct expression trees either from source code or by manually drawing
the trees.

\section{Challenges}\label{sec:intro-problem}

Let's consider three learning goals related to expressions:
\begin{enumerate*}
    \item Given some code, recognize the tokens that compose an expression.
    \item Given an expression, determine the type of the value it produces.
    \item Given an expression and the values of the used variables, evaluate
it and determine the value it produces.
\end{enumerate*}

To achieve these learning goals, an instructor may provide the students with
explanations about the concepts, worked examples and exercises.
With larger number of students to manage, assessing their code comprehension
abilities becomes a very expensive investment in terms of time for instructors.
This encourages the use of more trivial assessments such as unit testing, or
code style static analysis. These do not have a definite correlation to code
comprehension as they focus more on correctness and styling of the code.
The situation becomes even worse if we specifically want to assess code 
comprehension of the students' own code.

This thesis describes the design and implementation of a system that can
automatically assess student understanding of expressions in their own
code at scale. To do so, we need to overcome a number of challenges:

\begin{itemize}
    \item[(P1)] How can an instructor specify what kind of questions to ask to
students?
    \item[(P2)] How can we generate personalized questions at scale for all the 
different students?
    \item[(P3)] How can both students and instructors receive meaningful feedback?
Students are more interested in understanding the correctness of their
submission, while instructors find more useful looking at the \textit{bigger 
picture} to verify whether the learning experience of students is in line with
the learning goals.
\end{itemize}

In the context of the Expression Tutor platform, there exist Expression Tutor
activities. These ask the student to draw the expression tree for a given code
snippet (specifically a highlighted expression).
This task requires the student to decompose the given expression into
multiple sub–expressions. This activity challenges the understanding of both the
structure (associativity, operator precedence, identifying operator tokens) and 
the semantics of expressions (for typing and evaluation).

While providing an extremely important learning value, these activities can be
quite time consuming not only to design but also to assess.

\section{Contributions}\label{sec:intro-contrib}

The contributions to the platform presented and implemented in this document
are as follows:

\begin{enumerate}
    \item A system that can identify expressions in a code–base given a focus
query that aligns with the instructor's learning goals. (P1)
    \item A system to generate personalized learning activities for
students. (P2)
    \item A system to automatically assess the students' submissions of said
activities and generate feedback for both instructors and students. (P3)
\end{enumerate}

By leveraging the existing capabilities of the Expression Tutor platform of
analyzing (syntactically correct) source code and convert expressions to
expression tree diagrams, we can generate at scale any number of Expression
Tutor activities.

This means that every student can get unique exercises on expressions taken 
from their own source code. This reduces the friction that would come from the
need of understanding some code they are not familiar with.

We begin by introducing ``Expression Tree Language'', as a means to represent and
query expression trees (and thus expressions in source code). Being able
to query expression trees is fundamental as it allows instructors to select 
particular expressions that share certain traits among different code–bases and 
are aligned to their own learning goals (\textbf{Chapter~\ref{sec:etl}}).

For each expression, we generate its corresponding expression tree and
use it as a basis to generate learning activities on the Expression Tutor
platform. Each student gets a personalized activity based on their own
code (\textbf{Chapters~\ref{sec:dn}~and~\ref{sec:impl}}).

Finally we augment the Expression Tutor platform to support performing
automatic assessment of the students' submissions (\textbf{Chapter~\ref{sec:fb}}).
By using the information generated during the assessment process, formative
feedback is provided to students. For instructors, instead, we aggregate feedback
about all of each student's submission, with the possibility of inspecting each
student submission individually.

\end{chapterBody}
