
@inproceedings{kumar_effects_2007,
	address = {NLD},
	title = {The {Effects} of {Error}-{Flagging} in a {Tutor} on {Expression} {Evaluation}},
	isbn = {978-1-58603-764-2},
	abstract = {We evaluated the effect of providing error-flagging as support for error detection, but not error correction while the student is solving a problem. We found that providing error-flagging in addition to demand feedback during practice learning was no more effective than providing only demand feedback when the tutor did not explicitly mention that errors were being flagged. On the other hand, explaining and providing error-flagging without demand feedback during pre-and post-tests resulted in significantly better scores on pre-and post-tests even though error-flagging did not provide any error-correction support.},
	urldate = {2021-06-06},
	booktitle = {Proceedings of the 2007 conference on {Artificial} {Intelligence} in {Education}: {Building} {Technology} {Rich} {Learning} {Contexts} {That} {Work}},
	publisher = {IOS Press},
	author = {Kumar, Amruth and Rutigliano, Peter},
	month = jun,
	year = {2007},
	note = {tex.ids= kumarEffectsErrorFlaggingTutor2007
pages: 601},
	keywords = {Demand Feedback, Error Correction, Error Detection, Error-Flagging, Expression Evaluation},
	pages = {599--601},
	file = {Kumar and Rutigliano - 2007 - The Effects of Error-Flagging in a Tutor on Expres.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/8B8RVMMT/Kumar and Rutigliano - 2007 - The Effects of Error-Flagging in a Tutor on Expres.pdf:application/pdf},
}

@inproceedings{kumar_effectiveness_2015,
	address = {Kansas City Missouri USA},
	title = {The {Effectiveness} of {Visualization} for {Learning} {Expression} {Evaluation}},
	isbn = {978-1-4503-2966-8},
	url = {https://dl.acm.org/doi/10.1145/2676723.2677301},
	doi = {10.1145/2676723.2677301},
	language = {en},
	urldate = {2021-06-01},
	booktitle = {Proceedings of the 46th {ACM} {Technical} {Symposium} on {Computer} {Science} {Education}},
	publisher = {ACM},
	author = {Kumar, Amruth N.},
	month = feb,
	year = {2015},
	pages = {362--367},
	file = {Kumar - 2015 - The Effectiveness of Visualization for Learning Ex.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/NBY4GETM/Kumar - 2015 - The Effectiveness of Visualization for Learning Ex.pdf:application/pdf},
}

@mastersthesis{aalvik_visast_2019,
	title = {{VisAST}: {Generic} {AST} {Visualiser} for {Software} {Language} {Education}},
	abstract = {Structural concepts, like abstract syntax trees (ASTs), are often best explained through vi- sual representations. Students seem to have little trouble understanding what is presented to them visually, but they find it harder to translate their visual conception into source code when programming assignments on their own. Few resources are available to help students make this connection between visual and textual representations.
We developed a tool, visAST, for dynamically visualising ASTs of small languages writ- ten in Haskell, to help students connect the visual representations of ASTs to their own source code. The goal was to make the visualisations of visAST effortless to adopt for any new language that the students define. To assess the benefits and usability of visAST we conducted a user study, where visAST was used while implementing a simple interpreter. We asked students about their opinions on the tool and measured their performance with and without visAST. Our results show that students like visAST and find it useful. The results also suggest that visAST slightly improved students’ performance in a programming class.},
	language = {en},
	school = {Universitet I Bergen},
	author = {Aalvik, Ragnhild},
	month = may,
	year = {2019},
	file = {Aalvik - 2019 - VisAST.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/B96UTLX2/Aalvik - 2019 - VisAST.pdf:application/pdf},
}

@incollection{geuvers_vmext_2017,
	address = {Cham},
	title = {{VMEXT}: {A} {Visualization} {Tool} for {Mathematical} {Expression} {Trees}},
	volume = {10383},
	isbn = {978-3-319-62074-9 978-3-319-62075-6},
	shorttitle = {{VMEXT}},
	url = {http://link.springer.com/10.1007/978-3-319-62075-6_24},
	abstract = {Mathematical expressions can be represented as a tree consisting of terminal symbols, such as identiﬁers or numbers (leaf nodes), and functions or operators (non-leaf nodes). Expression trees are an important mechanism for storing and processing mathematical expressions as well as the most frequently used visualization of the structure of mathematical expressions. Typically, researchers and practitioners manually visualize expression trees using general-purpose tools. This approach is laborious, redundant, and error-prone. Manual visualizations represents a user’s notion of what the markup of an expression should be, but not necessarily what the actual markup is. This paper presents VMEXT – a free and open source tool to directly visualize expression trees from parallel MathML. VMEXT simultaneously visualizes the presentation elements and the semantic structure of mathematical expressions to enable users to quickly spot deﬁciencies in the Content MathML markup that does not aﬀect the presentation of the expression. Identifying such discrepancies previously required reading the verbose and complex MathML markup. VMEXT also allows one to visualize similar and identical elements of two expressions. Visualizing expression similarity can support developers in designing retrieval approaches and enable improved interaction concepts for users of mathematical information retrieval systems. We demonstrate VMEXT’s visualizations in two web-based applications. The ﬁrst application presents the visualizations alone. The second application shows a possible integration of the visualizations in systems for mathematical knowledge management and mathematical information retrieval. The application converts LATEX input to parallel MathML, computes basic similarity measures for mathematical expressions, and visualizes the results using VMEXT.},
	language = {en},
	urldate = {2021-05-23},
	booktitle = {Intelligent {Computer} {Mathematics}},
	publisher = {Springer International Publishing},
	author = {Schubotz, Moritz and Meuschke, Norman and Hepp, Thomas and Cohl, Howard S. and Gipp, Bela},
	editor = {Geuvers, Herman and England, Matthew and Hasan, Osman and Rabe, Florian and Teschke, Olaf},
	year = {2017},
	doi = {10.1007/978-3-319-62075-6_24},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {340--355},
	file = {Schubotz et al. - 2017 - VMEXT A Visualization Tool for Mathematical Expre.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/QBPMFR8B/Schubotz et al. - 2017 - VMEXT A Visualization Tool for Mathematical Expre.pdf:application/pdf},
}

@article{soloway_learning_1986,
	title = {Learning to program = learning to construct mechanisms and explanations},
	volume = {29},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/6592.6594},
	doi = {10.1145/6592.6594},
	abstract = {Teaching effective problem-solving skills in the context of teaching programming necessitates a revised curriculum for introductory computer programming courses.},
	number = {9},
	urldate = {2020-11-30},
	journal = {Communications of the ACM},
	author = {Soloway, E.},
	month = sep,
	year = {1986},
	note = {00577
tex.ids: solowayLearningProgramLearning1986},
	keywords = {proposedByIgor},
	pages = {850--858},
	file = {Soloway - 1986 - Learning to Program = Learning to Construct Mechanisms and Explanations.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/CZUFC9AU/Soloway - 1986 - Learning to Program = Learning to Construct Mechanisms and Explanations.pdf:application/pdf;Soloway - 1986 - Learning to program = learning to construct mechanisms and explanations.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/YVGUUUCM/Soloway - 1986 - Learning to program = learning to construct mechanisms and explanations.pdf:application/pdf;Soloway - 1986 - Learning to program = learning to construct mechanisms and explanations.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/MSY49CGW/Soloway - 1986 - Learning to program = learning to construct mechanisms and explanations.pdf:application/pdf},
}

@inproceedings{fincher_notional_2020,
	address = {New York, NY, USA},
	series = {{ITiCSE}-{WGR} '20},
	title = {Notional {Machines} in {Computing} {Education}: {The} {Education} of {Attention}},
	isbn = {978-1-4503-8293-9},
	shorttitle = {Notional {Machines} in {Computing} {Education}},
	url = {https://doi.org/10.1145/3437800.3439202},
	doi = {10.1145/3437800.3439202},
	abstract = {This report defines notional machines (NMs), and provides a series of definitional characteristics by which they may be identified. Over several sections, it includes a first-hand report of the origin of NMs, reports a systematic literature review to track the use and development of the concept, and presents a small collection of examples collected through interviews with experienced teachers. Additionally, the report presents NMs in a common format, and makes some preliminary explorations of their use in practice, including examples of instructors using multiple NMs in sequence. Approach and method are fully detailed in evidential appendices, to support replication of results and adoption/adaptation of practice.},
	urldate = {2020-12-30},
	booktitle = {Proceedings of the {Working} {Group} {Reports} on {Innovation} and {Technology} in {Computer} {Science} {Education}},
	publisher = {Association for Computing Machinery},
	author = {Fincher, Sally and Jeuring, Johan and Miller, Craig S. and Donaldson, Peter and du Boulay, Benedict and Hauswirth, Matthias and Hellas, Arto and Hermans, Felienne and Lewis, Colleen and Mühling, Andreas and Pearce, Janice L. and Petersen, Andrew},
	month = jun,
	year = {2020},
	note = {00000 
tex.ids: fincherNotionalMachinesComputing2020},
	keywords = {computing education, notional machines},
	pages = {21--50},
	file = {Fincher et al - 2020 - Notional Machines in Computing Education.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/IVSVSA8V/Fincher et al - 2020 - Notional Machines in Computing Education.pdf:application/pdf},
}

@book{pierce_types_2002,
	address = {Cambridge, Mass},
	title = {Types and programming languages},
	isbn = {978-0-262-16209-8},
	language = {en},
	publisher = {MIT Press},
	author = {Pierce, Benjamin C.},
	year = {2002},
	note = {03265},
	keywords = {Programming languages (Electronic computers)},
	annote = {Gallidabino's Notes
JavaScript
Term:- variable        `const x`         is    `x`- abstraction    `x ={\textgreater} x`        is    `λx.x`- application    `(x ={\textgreater} x)(y)`  is    `λx.x y`
 
Church booleans
- true = λt. λf. t   const tru = t ={\textgreater} f ={\textgreater} t
- false = λt. λf. f   const fls = t ={\textgreater} f ={\textgreater} f
 
- test = λl. λm. λn. l m n;   const test = l ={\textgreater} m ={\textgreater} n ={\textgreater} l(m)(n)
- and = λb. λc. b c fls   const and = b ={\textgreater} c ={\textgreater} b(c)(fls)
- or = λb. λc. b tru c   const or = b ={\textgreater} c ={\textgreater} b(tru)(c)
- not = λb. b fls tru   const not = b ={\textgreater} b(fls)(tru)
- nand = λb. λc. not (and b c)    const nand = b ={\textgreater} c ={\textgreater} not(and(b)(c))
- nor = λb. λc. not (or a b)  const nor = b ={\textgreater} c ={\textgreater} not(or(b)(c))
(xor implemented following https://en.wikipedia.org/wiki/NAND\_logic)- xor = λb. λc. nand(nand b (nand b c))(nand c (nand b c))    const xor = b ={\textgreater} c ={\textgreater} nand(nand(b)(nand(b)(c)))(nand(c)(nand(b)(c)))  
 
Copy paste in node:
const tru = t ={\textgreater} f ={\textgreater} tconst fls = t ={\textgreater} f ={\textgreater} fconst and = b ={\textgreater} c ={\textgreater} b(c)(fls)const or = b ={\textgreater} c ={\textgreater} b(tru)(c)const not = b ={\textgreater} b(fls)(tru)const nor = b ={\textgreater} c ={\textgreater} not(or(b)(c))const nand = b ={\textgreater} c ={\textgreater} not(and(b)(c))const xor = b ={\textgreater} c ={\textgreater} nand(nand(b)(nand(b)(c)))(nand(c)(nand(b)(c)))},
	annote = {Luca's Notes
 
const tru = t ={\textgreater} f ={\textgreater} t;const fls = t ={\textgreater} f ={\textgreater} f;const test = l ={\textgreater} m ={\textgreater} n ={\textgreater} l(m)(n);{\textgreater} test(tru)("a")("b")'a'ANDconst and = b ={\textgreater} c ={\textgreater} b(c)(fls);{\textgreater} and(tru)(tru)[Function: tru]OR/NOTconst or = b ={\textgreater} c ={\textgreater} b(tru)(c);const not = b ={\textgreater} b(fls)(tru);------New notes from page 60const pair = f ={\textgreater} s ={\textgreater} b ={\textgreater} b(f)(s)const fst = p ={\textgreater} p(tru)const snd = p ={\textgreater} p(fls)Example: fst(pair(10)(20))----- Church NumeralsEx5.2.2: scc = λn. λs. s n (?)Ex5.2.3: times = λm. λn. λz. m n zzz = truss = arg ={\textgreater} flsscc = s ={\textgreater} n ={\textgreater} s(n)plus = m ={\textgreater} n ={\textgreater} s ={\textgreater} z ={\textgreater} m(s)(n(s)(z))iszero = n ={\textgreater} n(ss)(zz)},
	annote = {Matthias' Notes
See Expression Tutor
Build lambda calculus activities that are about lambda calculus (closely matched to the activities in this book chapter).
See Miro board:https://miro.com/app/board/o9J\_lfPD\_Os=/
 
Create a course teaching lambda calculus top down (starting with a high-level PL) instead of bottom up (starting from math/first princples, as in TAPL).
 
Fantastic how 5.2 builds up all the useful features from scratch, in a beautiful sequence:

Multi-argument functions (currying)
Church Booleans
Pairs
Church Numerals

Omega: Divergent Combinator
omega = ({\textbackslash}x. x x) ({\textbackslash}x. x x)
https://expressiontutor.org/activity/do?task=b58e5e92-8998-450f-b52a-46192dc6d6cb
In Java?
Lambda omega = ( (Lambda)(x -{\textgreater} x.apply(x))).apply( x -{\textgreater} x.apply(x));
 
Fix: Fixed-Point Combinator
(call-by-value Y-combinator)
fix = {\textbackslash}f. ({\textbackslash}x. f ({\textbackslash}y. x x y)) ({\textbackslash}x. f ({\textbackslash}y. x x y))
https://expressiontutor.org/activity/do?task=0b1270fd-8667-48dd-b6f5-1c3993c1d52b
In Java?
Lambda fix = f -{\textgreater} ( ( (Lambda)(x -{\textgreater} f.apply( y -{\textgreater} x.apply(x).apply(y) )) ).apply( x -{\textgreater} f.apply( y -{\textgreater} x.apply(x).apply(y) ) ));
 
Note:
call-by-name Y-combinator:
Y = {\textbackslash}f. ({\textbackslash}x. f (x x)) ({\textbackslash}x. f (x x))
 
 
 },
	annote = {Read Chapter 5 on Untyped Lambda Calculus
Pages 51 - 59
ONLY AFTER, WATCH THE Computerphile video
 
 
5. Untyped Lambda Calculus
5.1 Basics
Abstract and Concrete Syntax
Variables and Metavariables
Scope
Operational Semantics
full beta-reduction strategy
normal order strategy
call by name strategy
call by value strategy
5.2 Programming in the Lambda-Calculus
Multiple Arguments
Church Booleans
{\textless}-- Matthias read up to here (page 59)
Pairs
Church Numerals
Enriching the Calculus
Recursion
Representation
5.3 Formalities
Syntax
Substitution
Operational Semantics
5.4 Notes
 },
	file = {Pierce - 2002 - Types and programming languages.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/HAUXKJJ5/Pierce - 2002 - Types and programming languages.pdf:application/pdf;week03.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/QBWD83QH/week03.pdf:application/pdf},
}

@book{felleisen_how_2014,
	edition = {Second Edition},
	title = {How to {Design} {Programs}},
	url = {https://htdp.org/},
	urldate = {2020-11-10},
	publisher = {MIT Press},
	author = {Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew and Krishnamurthi, Shriram},
	month = aug,
	year = {2014},
	note = {00370},
	file = {How to Design Programs:/Users/joey/Library/Application Support/Zotero/data/storage/XLZQ39GU/htdp.org.html:text/html},
}

@inproceedings{sirkia_exploring_2014,
	address = {Koli, Finland},
	title = {Exploring expression-level program visualization in {CS1}},
	isbn = {978-1-4503-3065-7},
	url = {http://dl.acm.org/citation.cfm?doid=2674683.2674687},
	doi = {10.1145/2674683.2674687},
	abstract = {Currently, most of the existing program visualization systems use line-based visualization. Another option is to have expression-level visualization which uses ﬁner granularity to provide more details about the execution. This helps novice programmers to understand the integral role of the expression evaluation and the correct execution model. Expression-level visualization can be useful, for example, to demonstrate function calls and object-oriented programming among the other basic features. However, creating program visualizations at expression-level is diﬃcult because there are few suitable means to generate all the required information they need. Static code analysis combined with the line-based tracing information may oﬀer new ways to solve the technical problems in creating expression-level visualizations.},
	language = {en},
	urldate = {2020-06-22},
	booktitle = {Proceedings of the 14th {Koli} {Calling} {International} {Conference} on {Computing} {Education} {Research} - {Koli} {Calling} '14},
	publisher = {ACM Press},
	author = {Sirkiä, Teemu},
	year = {2014},
	pages = {153--157},
	file = {Sirkiä - 2014 - Exploring expression-level program visualization in CS1.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/QD4HRMCW/Sirkiä - 2014 - Exploring expression-level program visualization in CS1.pdf:application/pdf},
}

@inproceedings{seppala_we_2015,
	address = {New York, NY, USA},
	series = {Koli {Calling} '15},
	title = {Do {We} {Know} {How} {Difficult} the {Rainfall} {Problem} is?},
	isbn = {978-1-4503-4020-5},
	url = {http://doi.acm.org/10.1145/2828959.2828963},
	doi = {10.1145/2828959.2828963},
	abstract = {The programming task known as the Rainfall Problem has developed a reputation for being surprisingly difficult for introductory-level (CS1) students. We contribute a survey of studies of the problem as well as a new study of students' solutions collected at three institutions. In all three CS1s, at least about half of the students were able to fully solve the problem and the large majority were at least close. Failure to handle invalid or missing input accounted for most bugs. Our survey and study together suggest that the Rainfall Problem is not necessarily overwhelmingly difficult: Success rates vary and some reasonably good results have been achieved under multiple programming paradigms. We provide a breakdown of confounding factors and suggest improvements and hypotheses for future studies of the Rainfall Problem.},
	urldate = {2018-12-11},
	booktitle = {Proceedings of the 15th {Koli} {Calling} {Conference} on {Computing} {Education} {Research}},
	publisher = {ACM},
	author = {Seppälä, Otto and Ihantola, Petri and Isohanni, Essi and Sorva, Juha and Vihavainen, Arto},
	year = {2015},
	keywords = {To Read, CS1, novice programmers, benchmark, rainfall problem},
	pages = {87--96},
	file = {Seppälä et al - 2015 - Do We Know How Difficult the Rainfall Problem is.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/WSH9L849/Seppälä et al - 2015 - Do We Know How Difficult the Rainfall Problem is.pdf:application/pdf},
}

@inproceedings{fisler_recurring_2014,
	address = {New York, NY, USA},
	series = {{ICER} '14},
	title = {The {Recurring} {Rainfall} {Problem}},
	isbn = {978-1-4503-2755-8},
	url = {http://doi.acm.org/10.1145/2632320.2632346},
	doi = {10.1145/2632320.2632346},
	abstract = {Many studies have used Soloway's Rainfall problem to explore plan composition and programming errors by novice programmers. Few of these have explored students from CS1 courses that use functional programming. The concepts and programming styles commonly taught in such courses give CS1 students more viable plan-composition options than in traditional imperative CS1 courses. Using data from five functional-language CS1 courses at four schools, we show that our students choose different high-level structures and make fewer low-level errors compared to results of other Rainfall studies. We discuss the potential role of language in these results and raise various questions that could further explore these effects.},
	urldate = {2018-12-11},
	booktitle = {Proceedings of the {Tenth} {Annual} {Conference} on {International} {Computing} {Education} {Research}},
	publisher = {ACM},
	author = {Fisler, Kathi},
	year = {2014},
	note = {tex.ids: fislerRecurringRainfallProblem2014a},
	keywords = {functional programming, novice programmers, plan composition},
	pages = {35--42},
	file = {Fisler - 2014 - The Recurring Rainfall Problem.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/PG5Q74LX/Fisler - 2014 - The Recurring Rainfall Problem.pdf:application/pdf},
}

@inproceedings{simon_soloways_2013,
	title = {Soloway's {Rainfall} {Problem} {Has} {Become} {Harder}},
	doi = {10.1109/LaTiCE.2013.44},
	abstract = {Discussing the use of plans in programming and in programming education, Soloway describes a programming task that has come to be known as the rainfall problem. This problem was used in a number of empirical experiments in the 1980s and 1990s, and was generally recognised as being quite difficult for student programmers. This paper reports that when the rainfall problem was recently used as an examination question in an introductory programming course, the students performed extremely poorly on it. These students are presumably no better than the many students who have been set this problem in the past, but it also appears that the problem has become harder than it was 20 years ago. For example, the problem assumes that loop-controlled keyboard input is standard, whereas in many programming environments nowadays the standard has become event-driven GUI input. As a consequence of this change, students are less likely to be familiar with loop-controlled keyboard input and with the use of a sentinel to terminate input, another feature of the rainfall problem. While there is potential value in comparing the performance of today's students with that in the literature of past decades, it is important to consider changes in technology that might impose a different level of challenge on the same problem.},
	booktitle = {2013 {Learning} and {Teaching} in {Computing} and {Engineering}},
	author = {{Simon}},
	month = mar,
	year = {2013},
	keywords = {Education, programming, programming education, computer science education, Programming profession, Arrays, Context, event-driven GUI input, graphical user interface, graphical user interfaces, Indexes, introductory programming course, Keyboards, loop-controlled keyboard input, rainfall, Soloway, Soloway rainfall problem, student programmer},
	pages = {130--135},
	file = {IEEE Xplore Abstract Record:/Users/joey/Library/Application Support/Zotero/data/storage/FU259VBA/6542249.html:text/html;Simon - 2013 - Soloway's Rainfall Problem Has Become Harder.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/KI75TELB/Simon - 2013 - Soloway's Rainfall Problem Has Become Harder.pdf:application/pdf},
}

@incollection{orey_model-based_2009,
	address = {Boston, MA},
	title = {Model-{Based} {Methods} for {Assessment}, {Learning}, and {Instruction}: {Innovative} {Educational} {Technology} at {Florida} {State} {University}},
	volume = {34},
	isbn = {978-0-387-09674-2 978-0-387-09675-9},
	shorttitle = {Model-{Based} {Methods} for {Assessment}, {Learning}, and {Instruction}},
	url = {http://link.springer.com/10.1007/978-0-387-09675-9_5},
	abstract = {In this chapter, we describe our research and development efforts relating to eliciting, representing, and analyzing how individuals and small groups conceptualize complex problems. The methods described herein have all been developed and are in various states of being validated. In addition, the methods we describe have been automated and most have been integrated in an online modelbased set of tools called HIMATT (Highly Interactive Model-based Assessment Tools and Technologies; available for research purposes at http://himatt.ezw.unifreiburg.de/cgi-bin/hrun/himatt.pl and soon to be available on a server at Florida State University). HIMATT continues to expand in terms of the tools and technologies included. Our methods and tools represent an approach to learning and instruction that is now embedded in many of the graduate courses at Florida State University and also at the University of Freiburg. We call our approach model-based because it integrates representations of mental models and internal cognitive processes with tools that are used to (a) assess progress of learning, and (b) provide the basis for informative and reﬂective feedback during instruction.},
	language = {en},
	urldate = {2018-12-28},
	booktitle = {Educational {Media} and {Technology} {Yearbook}},
	publisher = {Springer US},
	author = {Shute, Valerie J. and Jeong, Allan C. and Spector, J. Michael and Seel, Norbert M. and Johnson, Tristan E.},
	editor = {Orey, Michael and McClendon, V. J. and Branch, Robert Maribe},
	year = {2009},
	doi = {10.1007/978-0-387-09675-9_5},
	keywords = {To Read, Mental models, Belief networks, Causal diagrams, Cognitive modeling, Concept mapping, Model-based assessment, Technology-based assessment},
	pages = {61--79},
	file = {Shute et al - 2009 - Model-Based Methods for Assessment, Learning, and Instruction.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/IK95E57H/Shute et al - 2009 - Model-Based Methods for Assessment, Learning, and Instruction.pdf:application/pdf},
}

@inproceedings{pieterse_automated_2013,
	address = {Open Univ., Heerlen, The Netherlands, The Netherlands},
	series = {{CSERC} '13},
	title = {Automated {Assessment} of {Programming} {Assignments}},
	url = {http://dl.acm.org/citation.cfm?id=2541917.2541921},
	abstract = {This is a position paper in which I argue that massive open online programming courses can benefit by the application of automated assessment of programming assignments. I gathered success factors and identified concerns related to automatic assessment through the analysis of experiences other researchers have reported when designing and using automated assessment of programming assignments and interpret their potential applicability in the context of massive open online courses (MOOCs). In this paper I explain the design of our own assessment software and discuss our experience of using it in relation to the above-mentioned factors and concerns. My reflection on this experience can inform MOOC designers when having to make decisions regarding the use of automatic assessment of programming assignments.},
	urldate = {2019-09-27},
	booktitle = {Proceedings of the 3rd {Computer} {Science} {Education} {Research} {Conference} on {Computer} {Science} {Education} {Research}},
	publisher = {Open Universiteit, Heerlen},
	author = {Pieterse, Vreda},
	year = {2013},
	note = {event-place: Arnhem, Netherlands},
	keywords = {MOOC, Assessment software, automatic assessment},
	pages = {4:45--4:56},
	file = {ACM Full Text PDF:/Users/joey/Library/Application Support/Zotero/data/storage/9JAJ8XTS/Pieterse - 2013 - Automated Assessment of Programming Assignments.pdf:application/pdf},
}

@inproceedings{mccracken_multi-national_2001,
	address = {New York, NY, USA},
	series = {{ITiCSE}-{WGR} '01},
	title = {A {Multi}-national, {Multi}-institutional {Study} of {Assessment} of {Programming} {Skills} of {First}-year {CS} {Students}},
	url = {http://doi.acm.org/10.1145/572133.572137},
	doi = {10.1145/572133.572137},
	abstract = {In computer science, an expected outcome of a student's education is programming skill. This working group investigated the programming competency students have as they complete their first one or two courses in computer science. In order to explore options for assessing students, the working group developed a trial assessment of whether students can program. The underlying goal of this work was to initiate dialog in the Computer Science community on how to develop these types of assessments. Several universities participated in our trial assessment and the disappointing results suggest that many students do not know how to program at the conclusion of their introductory courses. For a combined sample of 216 students from four universities, the average score was 22.89 out of 110 points on the general evaluation criteria developed for this study. From this trial assessment we developed a framework of expectations for first-year courses and suggestions for further work to develop more comprehensive assessments.},
	urldate = {2018-10-08},
	booktitle = {Working {Group} {Reports} from {ITiCSE} on {Innovation} and {Technology} in {Computer} {Science} {Education}},
	publisher = {ACM},
	author = {McCracken, Michael and Almstrum, Vicki and Diaz, Danny and Guzdial, Mark and Hagan, Dianne and Kolikant, Yifat Ben-David and Laxer, Cary and Thomas, Lynda and Utting, Ian and Wilusz, Tadeusz},
	year = {2001},
	note = {tex.ids: mccrackenMultinationalMultiinstitutionalStudy},
	pages = {125--180},
	file = {McCracken et al - A multi-national, multi-institutional study of assessment of programming skills.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/X3VLJNDB/McCracken et al - A multi-national, multi-institutional study of assessment of programming skills.pdf:application/pdf},
}

@phdthesis{dave_berry_generating_1991,
	type = {{PhD} {Thesis}},
	title = {Generating {Program} {Animations} from {Programming} {Language} {Semantics}},
	url = {http://www.lfcs.inf.ed.ac.uk/reports/91/ECS-LFCS-91-163/ECS-LFCS-91-163.pdf},
	urldate = {2021-03-08},
	school = {University of Edinburgh},
	author = {{Dave Berry}},
	year = {1991},
	note = {00000},
	file = {Dave Berry - 1991 - Generating Program Animations from Programming Language Semantics.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/82SIE333/Dave Berry - 1991 - Generating Program Animations from Programming Language Semantics.pdf:application/pdf},
}

@article{keuning_systematic_2019,
	title = {A {Systematic} {Literature} {Review} of {Automated} {Feedback} {Generation} for {Programming} {Exercises}},
	volume = {19},
	issn = {1946-6226},
	url = {https://dl.acm.org/doi/10.1145/3231711},
	doi = {10.1145/3231711},
	abstract = {Formative feedback, aimed at helping students to improve their work, is an important factor in learning. Many tools that offer programming exercises provide automated feedback on student solutions. We have performed a systematic literature review to find out what kind of feedback is provided, which techniques are used to generate the feedback, how adaptable the feedback is, and how these tools are evaluated. We have designed a labelling to classify the tools, and use Narciss’ feedback content categories to classify feedback messages. We report on the results of coding a total of 101 tools. We have found that feedback mostly focuses on identifying mistakes and less on fixing problems and taking a next step. Furthermore, teachers cannot easily adapt tools to their own needs. However, the diversity of feedback types has increased over the past decades and new techniques are being applied to generate feedback that is increasingly helpful for students.},
	language = {en},
	number = {1},
	urldate = {2021-08-19},
	journal = {ACM Transactions on Computing Education},
	author = {Keuning, Hieke and Jeuring, Johan and Heeren, Bastiaan},
	month = jan,
	year = {2019},
	pages = {1--43},
	file = {Keuning et al. - 2019 - A Systematic Literature Review of Automated Feedba.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/M2VE6LCJ/Keuning et al. - 2019 - A Systematic Literature Review of Automated Feedba.pdf:application/pdf},
}

@inproceedings{lehtinenLetAskStudents2021,
	title = {Let’s {Ask} {Students} {About} {Their} {Programs}, {Automatically}},
	doi = {10.1109/ICPC52881.2021.00054},
	abstract = {Students sometimes produce code that works but that its author does not comprehend. For example, a student may apply a poorly-understood code template, stumble upon a working solution through trial and error, or plagiarize. Similarly, passing an automated functional assessment does not guarantee that the student understands their code. One way to tackle these issues is to probe students’ comprehension by asking them questions about their own programs. We propose an approach to automatically generate questions about student-written program code. We moreover propose a use case for such questions in the context of automatic assessment systems: after a student’s program passes unit tests, the system poses questions to the student about the code. We suggest that these questions can enhance assessment systems, deepen student learning by acting as self-explanation prompts, and provide a window into students’ program comprehension. This discussion paper sets an agenda for future technical development and empirical research on the topic.},
	booktitle = {2021 {IEEE}/{ACM} 29th {International} {Conference} on {Program} {Comprehension} ({ICPC})},
	author = {Lehtinen, Teemu and Santos, André L. and Sorva, Juha},
	month = may,
	year = {2021},
	note = {ISSN: 2643-7171},
	keywords = {Education, Computer Science - Computers and Society, programming education, program comprehension, Proposals, Software, Automatic assessment, automatic question generation, Plagiarism, Probes, self-explanation},
	pages = {467--475},
	file = {Submitted Version:/Users/joey/Library/Application Support/Zotero/data/storage/C7XRGX2B/Lehtinen et al. - 2021 - Let’s Ask Students About Their Programs, Automatic.pdf:application/pdf},
}

@inproceedings{chiodiniCuratedInventoryProgramming2021,
	address = {New York, NY, USA},
	series = {{ITiCSE} '21},
	title = {A {Curated} {Inventory} of {Programming} {Language} {Misconceptions}},
	isbn = {978-1-4503-8214-4},
	url = {https://doi.org/10.1145/3430665.3456343},
	doi = {10.1145/3430665.3456343},
	abstract = {Knowledge about misconceptions is an important element of pedagogical content knowledge. The computing education research community collected a large body of research on misconceptions, using a diverse set of definitions and approaches. Inspired by this prior work, we present an actionable definition of misconceptions, focused on the area most commonly studied: programming and programming languages. We then introduce an organizational structure for collections of programming language misconceptions. We study how existing collections fit our organization, and we present a curated inventory of programming language misconceptions that aims to follow our definition and structure. Our inventory goes beyond traditional programming misconception collections. It connects misconceptions to the authoritative specifications of languages, to places they may be triggered in textbooks, to research papers that discuss them, and it provides support for integrating programming language misconceptions into educational platforms.},
	urldate = {2021-06-29},
	booktitle = {Proceedings of the 26th {ACM} {Conference} on {Innovation} and {Technology} in {Computer} {Science} {Education} {V}. 1},
	publisher = {Association for Computing Machinery},
	author = {Chiodini, Luca and Moreno Santos, Igor and Gallidabino, Andrea and Tafliovich, Anya and Santos, André L. and Hauswirth, Matthias},
	month = jun,
	year = {2021},
	keywords = {programming, misconceptions, pedagogy, programming languages},
	pages = {380--386},
	file = {Full Text PDF:/Users/joey/Library/Application Support/Zotero/data/storage/ZPCFHGPI/Chiodini et al. - 2021 - A Curated Inventory of Programming Language Miscon.pdf:application/pdf},
}

@misc{the_eclipse_foundation_jdt_2022,
	title = {{JDT} {Core} {Component}},
	url = {https://www.eclipse.org/jdt/core/index.php},
	abstract = {JDT Core is the Java infrastructure of the Java IDE. It includes:
• An incremental Java compiler. Implemented as an Eclipse builder, it is based on technology evolved from VisualAge for Java compiler. In particular, it allows to run and debug code which still contains unresolved errors.
• A Java Model that provides API for navigating the Java element tree. The Java element tree defines a Java centric view of a project. It surfaces elements like package fragments, compilation units, binary classes, types, methods, fields. 
• A Java Document Model providing API for manipulating a structured Java source document.
• Code assist and code select support.
• An indexed based search infrastructure that is used for searching, code assist, type hierarchy computation, and refactoring. The Java search engine can accurately find precise matches either in sources or binaries.
• Evaluation support either in a scrapbook page or a debugger context.
• Source code formatter},
	language = {en},
	urldate = {2022-08-26},
	author = {The Eclipse Foundation, JDT/Core},
	year = {2022},
	file = {Snapshot:/Users/joey/Library/Application Support/Zotero/data/storage/3FC5HEQD/index.html:text/html},
}

@inproceedings{clements_modeling_2001,
	address = {Berlin, Heidelberg},
	series = {{ESOP} '01},
	title = {Modeling an {Algebraic} {Stepper}},
	isbn = {978-3-540-41862-7},
	abstract = {Programmers rely on the correctness of the tools in their programming environments. In the past, semanticists have studied the correctness of compilers and compiler analyses, which are the most important tools. In this paper, we make the case that other tools, such as debuggers and steppers, deserve semantic models, too, and that using these models can help in developing these tools. Our concrete starting point is the algebraic stepper in DrScheme, our Scheme programming environment. The algebraic stepper explains a Scheme computation in terms of an algebraic rewriting of the program text. A program is rewritten until it is in a canonical form (if it has one). The canonical form is the final result. The stepper operates within the existing evaluator, by placing breakpoints and by reconstructing source expressions from source information placed on the stack. This approach raises two questions. First, do the run-time breakpoints correspond to the steps of the reduction semantics? Second, does the debugging mechanism insert enough information to reconstruct source expressions? To answer these questions, we develop a high-level semantic model of the extended compiler and run-time machinery. Rather than modeling the evaluation as a low-level machine, we model the relevant low-level features of the stepper's implementation in a high-level reduction semantics. We expect the approach to apply to other semantics-based tools.},
	urldate = {2022-03-01},
	booktitle = {Proceedings of the 10th {European} {Symposium} on {Programming} {Languages} and {Systems}},
	publisher = {Springer-Verlag},
	author = {Clements, John and Flatt, Matthew and Felleisen, Matthias},
	month = apr,
	year = {2001},
	pages = {320--334},
	file = {Clements et al. - 2001 - Modeling an Algebraic Stepper.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/BAIW8JGP/Clements et al. - 2001 - Modeling an Algebraic Stepper.pdf:application/pdf},
}

@inproceedings{donaldson_flexible_2018,
	address = {New York, NY, USA},
	series = {{WiPSCE} '18},
	title = {Flexible low-cost activities to develop novice code comprehension skills in schools},
	isbn = {978-1-4503-6588-8},
	url = {https://doi.org/10.1145/3265757.3265776},
	doi = {10.1145/3265757.3265776},
	abstract = {The lack of code comprehension skills in novice programming students is recognised as a major factor underpinning poor learning outcomes. We use Schulte's Block Model to support teachers' understanding of how to break the skill down into component parts that are more manageable for a learner. This analysis is operationalised in three code annotation-based learning/assessment exercise formats, two helping students to identify and describe programming concepts and the third enabling them to parse code correctly and carry out desk executions. A great benefit of the activities is that they are low cost and can be applied to any imperative style code and so can be easily adopted by schools anywhere; furthermore, they are active, not passive, an issue with some animation-based visualisation approaches. The exercise formats were included as part of a national schools computing science professional learning programme (PLAN C).},
	urldate = {2021-11-30},
	booktitle = {Proceedings of the 13th {Workshop} in {Primary} and {Secondary} {Computing} {Education}},
	publisher = {Association for Computing Machinery},
	author = {Donaldson, Peter and Cutts, Quintin},
	month = oct,
	year = {2018},
	keywords = {program comprehension, notional machine, block model, formative assessment},
	pages = {1--4},
	file = {Donaldson and Cutts - 2018 - Flexible low-cost activities to develop novice code comprehension skills in.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/3WK49SKS/Donaldson and Cutts - 2018 - Flexible low-cost activities to develop novice code comprehension skills in.pdf:application/pdf},
}

@incollection{goos_xpath_2002,
	address = {Berlin, Heidelberg},
	title = {{XPath}: {Looking} {Forward}},
	volume = {2490},
	isbn = {978-3-540-00130-0 978-3-540-36128-2},
	shorttitle = {{XPath}},
	url = {http://link.springer.com/10.1007/3-540-36128-6_7},
	abstract = {The location path language XPath is of particular importance for XML applications since it is a core component of many XML processing standards such as XSLT or XQuery. In this paper, based on axis symmetry of XPath, equivalences of XPath 1.0 location paths involving reverse axes, such as ancestor and preceding, are established. These equivalences are used as rewriting rules in an algorithm for transforming location paths with reverse axes into equivalent reverse-axis-free ones. Location paths without reverse axes, as generated by the presented rewriting algorithm, enable eﬃcient SAX-like streamed data processing of XPath.},
	language = {en},
	urldate = {2022-11-17},
	booktitle = {{XML}-{Based} {Data} {Management} and {Multimedia} {Engineering} — {EDBT} 2002 {Workshops}},
	publisher = {Springer Berlin Heidelberg},
	author = {Olteanu, Dan and Meuss, Holger and Furche, Tim and Bry, François},
	editor = {Goos, Gerhard and Hartmanis, Juris and van Leeuwen, Jan and Chaudhri, Akmal B. and Unland, Rainer and Djeraba, Chabane and Lindner, Wolfgang},
	year = {2002},
	doi = {10.1007/3-540-36128-6_7},
	note = {Series Title: Lecture Notes in Computer Science},
	keywords = {xpath},
	pages = {109--127},
	file = {Olteanu et al. - 2002 - XPath Looking Forward.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/KEGIR7N7/Olteanu et al. - 2002 - XPath Looking Forward.pdf:application/pdf},
}

@article{gottlob_xpath_2003,
	title = {{XPath} {Processing} in a {Nutshell}},
	doi = {10.1145/640990.640992},
	journal = {SIGMOD Record},
	author = {Gottlob, Georg and Koch, Christoph and Pichler, Reinhard},
	year = {2003},
	keywords = {xpath},
	file = {Submitted Version:/Users/joey/Library/Application Support/Zotero/data/storage/5QRV4CN7/Gottlob et al. - 2003 - XPath Processing in a Nutshell.pdf:application/pdf},
}

@misc{padioleau_semgrep_2021,
	title = {Semgrep, a fast, lightweight, polyglot, static analysis tool to find bugs ({OCaml} 2021) - {ICFP} 2021},
	url = {https://icfp21.sigplan.org/details/ocaml-2021-papers/18/Semgrep-a-fast-lightweight-polyglot-static-analysis-tool-to-find-bugs},
	abstract = {The OCaml Users and Developers Workshop brings together industrial users of OCaml with academics and hackers who are working on extending the language, type system, and tools. Previous editions have been co-located with ICFP 2012 in Copenhagen, ICFP 2013 in Boston, ICFP 2014 in Gothenburg, ICFP 2015 in Vancouver, ICFP 2016 in Nara, ICFP 2017 in Oxford, ICFP 2018 in St Louis, ICFP 2019 in Berlin, and was virtual for ICFP 2020, following the OCaml Meetings in Paris in 2010 and 2011. 
OCaml 2021 will be a virtual workshop, co-located with ICFP 2021. 
Please contact the PC Chair (Frédéric Bour ...},
	urldate = {2022-11-17},
	author = {Padioleau, Yoann},
	month = aug,
	year = {2021},
	keywords = {semgrep},
	annote = {semgrep-padioleau-august-2021.pdf},
	file = {Semgrep, a fast, lightweight, polyglot, static ana.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/QG88546N/Semgrep, a fast, lightweight, polyglot, static ana.pdf:application/pdf;Snapshot:/Users/joey/Library/Application Support/Zotero/data/storage/LNTCEHFI/Semgrep-a-fast-lightweight-polyglot-static-analysis-tool-to-find-bugs.html:text/html},
}

@misc{copeland_pmd_2002,
	title = {{PMD}},
	url = {https://pmd.github.io/#about},
	urldate = {2022-11-17},
	journal = {PMD},
	author = {Copeland, Tom},
	month = nov,
	year = {2002},
	file = {PMD:/Users/joey/Library/Application Support/Zotero/data/storage/Y3LTB4TF/pmd.github.io.html:text/html},
}

@inproceedings{collard_srcml_2016,
	title = {{srcML} 1.0: {Explore}, {Analyze}, and {Manipulate} {Source} {Code}},
	shorttitle = {{srcML} 1.0},
	doi = {10.1109/ICSME.2016.36},
	abstract = {Summary form only given. This technology briefing is intended for those interested in constructing custom software analysis and manipulation tools to support research or commercial applications. srcML (srcML.org) is an infrastructure consisting of an XML representation for C/C++/C\#/Java source code along with efficient parsing technology to convert source code to-and-from the srcML format. The briefing describes srcML, the toolkit, and the application of XPath and XSLT to query and modify source code. Additionally, a short tutorial of how to use srcML and XML tools to construct custom analysis and manipulation tools will be conducted.},
	booktitle = {2016 {IEEE} {International} {Conference} on {Software} {Maintenance} and {Evolution} ({ICSME})},
	author = {Collard, Michael L. and Maletic, Jonathan I.},
	month = oct,
	year = {2016},
	keywords = {Conferences, program transformation, Software maintenance, srcML, static program analysis, Tutorials, XML},
	pages = {649--649},
	file = {IEEE Xplore Abstract Record:/Users/joey/Library/Application Support/Zotero/data/storage/LJ4RENF6/7816536.html:text/html;IEEE Xplore Full Text PDF:/Users/joey/Library/Application Support/Zotero/data/storage/9BL989ED/Collard and Maletic - 2016 - srcML 1.0 Explore, Analyze, and Manipulate Source.pdf:application/pdf},
}

@article{lu_gradual_2022,
	title = {Gradual {Soundness}: {Lessons} from {Static} {Python}},
	volume = {7},
	issn = {2473-7321},
	shorttitle = {Gradual {Soundness}},
	url = {https://programming-journal.org/2023/7/2/},
	doi = {10.22152/programming-journal.org/2023/7/2},
	abstract = {Context: Gradually-typed languages allow typed and untyped code to interoperate, but typically come with significant drawbacks. In some l...},
	language = {en},
	number = {1},
	urldate = {2022-11-21},
	journal = {The Art, Science, and Engineering of Programming},
	author = {Lu, Kuang-Chen and Greenman, Ben and Meyer, Carl and Viehland, Dino and Panse, Aniket and Krishnamurthi, Shriram},
	month = jun,
	year = {2022},
	pages = {2:1--2:40},
	file = {Full Text PDF:/Users/joey/Library/Application Support/Zotero/data/storage/BV9UJNHZ/Lu et al. - 2022 - Gradual Soundness Lessons from Static Python.pdf:application/pdf;Snapshot:/Users/joey/Library/Application Support/Zotero/data/storage/VHP34NUK/2.html:text/html},
}

@article{zhang_simple_1989,
	title = {Simple {Fast} {Algorithms} for the {Editing} {Distance} {Between} {Trees} and {Related} {Problems}},
	volume = {18},
	doi = {10.1137/0218082},
	abstract = {Ordered labeled trees are trees in which the left-to-right order among siblings is significant. The distance between two ordered trees is considered to be the weighted number of edit operations (insert, delete, and modify) to transform one tree to another. The problem of approximate tree matching is also considered. Specifically, algorithms are designed to answer the following kinds of questions: 1. What is the distance between two trees? 2. What is the minimum distance between T 1 and T 2 when zero or more subtrees can be removed from T 2 ? 3. Let the pruning of a tree at node n mean removing all the descendants of node n. The analogous question for prunings as for subtrees is answered. A dynamic programming algorithm is presented to solve the three questions in sequential time O({\textbar}T 1 {\textbar}×{\textbar}T 2 {\textbar}×min(depth(T 1 ),leaves(T 1 ))×min(depth(T 2 ),leaves(T 2 ))) and space O({\textbar}T 1 {\textbar}×{\textbar}T 2 {\textbar}) compared with O({\textbar}T 1 {\textbar}×{\textbar}T 2 {\textbar}×(depth(T 1 )) 2 ×(depth(T 2 )) 2 ) for the best previous published algorithm due to Tai [J. Assoc. Comput. Mach. 26, 422-433 (1979; Zbl 0409.68040)]. Further, the algorithm presented here can be parallelized to give time O({\textbar}T 1 {\textbar}+{\textbar}T 2 {\textbar}).},
	journal = {SIAM J. Comput.},
	author = {Zhang, Kaizhong and Shasha, Dennis},
	month = dec,
	year = {1989},
	pages = {1245--1262},
	file = {Full Text PDF:/Users/joey/Library/Application Support/Zotero/data/storage/G9R5MEPY/Zhang and Shasha - 1989 - Simple Fast Algorithms for the Editing Distance Be.pdf:application/pdf},
}

@article{du_boulay_difficulties_1986,
	title = {Some {Difficulties} of {Learning} to {Program}},
	volume = {2},
	issn = {0735-6331},
	url = {https://doi.org/10.2190/3LFX-9RRF-67T8-UVK9},
	doi = {10.2190/3LFX-9RRF-67T8-UVK9},
	abstract = {This article is a brief introduction to some of the issues that teachers of programming may find helpful. It starts by presenting a fairly idiosyncratic view of teaching programming which makes use of mechanistic analogies and points out some of the pitfalls. The article goes on to examine certain errors based on the misapplication of analogies as well as certain interaction errors. The main emphasis is on the notional machine both at the general level of understanding (and misunderstanding) the relationship of the terminal to the computer as such, as well as at the more specific level of understanding assignment. Notation and mistakes that poorly-designed languages can induce novices to commit are discussed.},
	language = {en},
	number = {1},
	urldate = {2022-11-27},
	journal = {Journal of Educational Computing Research},
	author = {Du Boulay, Benedict},
	month = feb,
	year = {1986},
	note = {Publisher: SAGE Publications Inc},
	pages = {57--73},
}

@inproceedings{sychev_tool_2022,
	address = {New York, NY, USA},
	series = {{SIGCSE} 2022},
	title = {A {Tool} to {Teach} {Expressions} with {Feedback} {About} {Broken} {Laws}},
	isbn = {978-1-4503-9071-2},
	url = {https://doi.org/10.1145/3478432.3499082},
	doi = {10.1145/3478432.3499082},
	abstract = {We developed a web-based tool for learning the order of evaluating expressions in C++ and Python languages. The variety of operator precedence and associativity among programming languages and the lack of direct visualization make understanding expression evaluation difficult for some students. The key feature of the new system is a detailed explanation of errors, containing fault reasons---the subject domain laws that the student violated. We evaluated the tool with 14 first-year Computer Science students and received positive feedback. This tool can be used for learning new concepts during homework without requiring more class time because it provides enough feedback for students to learn on their own.},
	urldate = {2022-11-27},
	booktitle = {Proceedings of the 53rd {ACM} {Technical} {Symposium} on {Computer} {Science} {Education} {V}. 2},
	publisher = {Association for Computing Machinery},
	author = {Sychev, Oleg and Penskoy, Nikita and Terekhov, Grigory},
	month = mar,
	year = {2022},
	keywords = {introductory programming course, constraint-based intelligent tutor, expressions, order of evaluation, software reasoning},
	pages = {1158},
}

@inproceedings{leite_effects_2020,
	address = {New York, NY, USA},
	series = {{SIGCSE} '20},
	title = {Effects of {Human} vs. {Automatic} {Feedback} on {Students}' {Understanding} of {AI} {Concepts} and {Programming} {Style}},
	isbn = {978-1-4503-6793-6},
	url = {https://doi.org/10.1145/3328778.3366921},
	doi = {10.1145/3328778.3366921},
	abstract = {The use of automatic grading tools has become nearly ubiquitous in large undergraduate programming courses, and recent work has focused on improving the quality of automatically generated feedback. However, there is a relative lack of data directly comparing student outcomes when receiving computer-generated feedback and human-written feedback. This paper addresses this gap by splitting one 90-student class into two feedback groups and analyzing differences in the two cohorts' performance. The class is an intro to AI with programming HW assignments. One group of students received detailed computer-generated feedback on their programming assignments describing which parts of the algorithms' logic was missing; the other group additionally received human-written feedback describing how their programs' syntax relates to issues with their logic, and qualitative (style) recommendations for improving their code. Results on quizzes and exam questions suggest that human feedback helps students obtain a better conceptual understanding, but analyses found no difference between the groups' ability to collaborate on the final project. The course grade distribution revealed that students who received human-written feedback performed better overall; this effect was the most pronounced in the middle two quartiles of each group. These results suggest that feedback about the syntax-logic relation may be a primary mechanism by which human feedback improves student outcomes.},
	urldate = {2022-11-27},
	booktitle = {Proceedings of the 51st {ACM} {Technical} {Symposium} on {Computer} {Science} {Education}},
	publisher = {Association for Computing Machinery},
	author = {Leite, Abe and Blanco, Saúl A.},
	month = feb,
	year = {2020},
	keywords = {feedback, programming style, automatic grading, references to syntax, student outcomes, syntax-logic relation},
	pages = {44--50},
	file = {Submitted Version:/Users/joey/Library/Application Support/Zotero/data/storage/6VQK5C2I/Leite and Blanco - 2020 - Effects of Human vs. Automatic Feedback on Student.pdf:application/pdf},
}

@inproceedings{choudhury_autostyle_2016,
	address = {New York, NY, USA},
	series = {{CSCW} '16 {Companion}},
	title = {{AutoStyle}: {Toward} {Coding} {Style} {Feedback} {At} {Scale}},
	isbn = {978-1-4503-3950-6},
	shorttitle = {{AutoStyle}},
	url = {https://doi.org/10.1145/2818052.2874315},
	doi = {10.1145/2818052.2874315},
	abstract = {While large-scale automatic grading of student programs for correctness is widespread, less effort has focused on au-tomating feedback for good programming style: the tasteful use of language features and idioms to produce code that is not only correct, but also concise, elegant, and revealing of design intent. We hypothesize that with a large enough (MOOC-sized) corpus of submissions to a given program-ming problem, we can observe a range of stylistic mastery from naive to expert, and many points in between, and that we can exploit this continuum to automatically provide hints to learners to improve their code style based on the key stylistic differences between a given learner's submission and one that is stylistically slightly better. We present a sys-tem with two key interfaces. The first is an instructor-facing GUI that allows an instructor to browse student submis-sions clustered by stylistic patterns and view chains from a particular submission to a canonical one. The second is a student-facing GUI that allows a student to submit a solu-tion and receive instantaneous style feedback.},
	urldate = {2022-11-27},
	booktitle = {Proceedings of the 19th {ACM} {Conference} on {Computer} {Supported} {Cooperative} {Work} and {Social} {Computing} {Companion}},
	publisher = {Association for Computing Machinery},
	author = {Choudhury, Rohan Roy and Yin, HeZheng and Moghadam, Joseph and Fox, Armando},
	month = feb,
	year = {2016},
	keywords = {autograding, coding style, MOOCs},
	pages = {21--24},
}

@article{edwards_improving_2003,
	title = {Improving student performance by evaluating how well students test their own programs},
	volume = {3},
	issn = {1531-4278},
	url = {https://doi.org/10.1145/1029994.1029995},
	doi = {10.1145/1029994.1029995},
	abstract = {Students need to learn more software testing skills. This paper presents an approach to teaching software testing in a way that will encourage students to practice testing skills in many classes and give them concrete feedback on their testing performance, without requiring a new course, any new faculty resources, or a significant number of lecture hours in each course where testing will be practiced. The strategy is to give students basic exposure to test-driven development, and then provide an automated tool that will assess student submissions on-demand and provide feedback for improvement. This approach has been demonstrated in an undergraduate programming languages course using a prototype tool. The results have been positive, with students expressing appreciation for the practical benefits of test-driven development on programming assignments. Experimental analysis of student programs shows a 28\% reduction in defects per thousand lines of code.},
	number = {3},
	urldate = {2022-11-27},
	journal = {Journal on Educational Resources in Computing},
	author = {Edwards, Stephen H.},
	month = sep,
	year = {2003},
	keywords = {test-driven development, agile methods, extreme programming, teaching software testing, test-first coding},
	pages = {1--es},
}

@inproceedings{henz_stepper_2021,
	address = {New York, NY, USA},
	series = {{SPLASH}-{E} 2021},
	title = {A stepper for a functional {JavaScript} sublanguage},
	isbn = {978-1-4503-9089-7},
	url = {https://doi.org/10.1145/3484272.3484968},
	doi = {10.1145/3484272.3484968},
	abstract = {The first two chapters of the introductory computer science textbook Structure and Interpretation of Computer Programs, JavaScript Adaptation (SICP JS), use a subset of JavaScript called Source §2. The book introduces the reduction-based “substitution model” as a first mental model for the evaluation of Source §2 programs. To support the learner in adopting this mental model, we built an algebraic stepper—a tool for visualizing the evaluation of Source §2 programs according to the model. As a sublanguage of JavaScript, Source §2 differs from other purely functional programming languages by using a statement-oriented syntax, with statement sequences, return statements, and block-scoped declarations. For the purpose of this tool description, we distill these distinguishing features—along with explicit recursion—into a Source §2 sublanguage that we call Source §0, and focus on a stepper for this language. We formalize the substitution model of Source §0 as a lambda-calculus-style reduction semantics that handles explicit recursion by term graph rewriting and faithfully implements the JavaScript specification, when restricted to that language. Our implementation of the stepper represents term graphs by persistent data structures that maximize sharing and enable random access to all steps. This work presents the first reduction-based semantics for a JavaScript sublanguage and the first algebraic stepper for a language with return statements and block-scoped declarations. The tool supports the learner with step-level explanations, redex highlighting, and function-level skipping and can also be used for teaching the applicative-order-reduction lambda calculus.},
	urldate = {2022-11-28},
	booktitle = {Proceedings of the 2021 {ACM} {SIGPLAN} {International} {Symposium} on {SPLASH}-{E}},
	publisher = {Association for Computing Machinery},
	author = {Henz, Martin and Tan, Thomas and Chua, Zachary and Jung, Peter and Tan, Yee-Jian and Zhang, Xinyi and Zhao, Jingjing},
	month = oct,
	year = {2021},
	keywords = {education, semantics, JavaScript, programming environments, lambda calculus, functional languages, stepper, term graph rewriting},
	pages = {71--81},
	file = {Full Text PDF:/Users/joey/Library/Application Support/Zotero/data/storage/9M97N5UG/Henz et al. - 2021 - A stepper for a functional JavaScript sublanguage.pdf:application/pdf},
}

@misc{matthias_hauswirth_expression_2023,
	title = {Expression {Tutor}},
	url = {https://expressiontutor.org/},
	urldate = {2022-12-01},
	journal = {Expression Tutor},
	author = {{Matthias Hauswirth}},
	collaborator = {{Gallidabino Andrea} and {Moreno Santos Igor} and {Chiodini Luca}},
	year = {2023},
	file = {Expression Tutor:/Users/joey/Library/Application Support/Zotero/data/storage/AMQ6CTLW/expressiontutor.org.html:text/html},
}

@inproceedings{piech_learning_2015,
	address = {Lille, France},
	series = {{ICML}'15},
	title = {Learning program embeddings to propagate feedback on student code},
	abstract = {Providing feedback, both assessing final work and giving hints to stuck students, is difficult for open-ended assignments in massive online classes which can range from thousands to millions of students. We introduce a neural network method to encode programs as a linear mapping from an embedded precondition space to an embedded postcondition space and propose an algorithm for feedback at scale using these linear maps as features. We apply our algorithm to assessments from the Code.org Hour of Code and Stanford University's CS1 course, where we propagate human comments on student assignments to orders of magnitude more submissions.},
	urldate = {2022-12-07},
	booktitle = {Proceedings of the 32nd {International} {Conference} on {International} {Conference} on {Machine} {Learning} - {Volume} 37},
	publisher = {JMLR.org},
	author = {Piech, Chris and Huang, Jonathan and Nguyen, Andy and Phulsuksombati, Mike and Sahami, Mehran and Guibas, Leonidas},
	month = jul,
	year = {2015},
	pages = {1093--1102},
}

@article{thompson_programming_1968,
	title = {Programming {Techniques}: {Regular} expression search algorithm},
	volume = {11},
	issn = {0001-0782, 1557-7317},
	shorttitle = {Programming {Techniques}},
	url = {https://dl.acm.org/doi/10.1145/363347.363387},
	doi = {10.1145/363347.363387},
	abstract = {A method for locating specific character strings embedded in character text is described and an implementation of this method in the form of a compiler is discussed. The compiler accepts a regular expression as source language and produces an IBM 7 0 9 4 program as object language. The object program then accepts the text to be searched as input and produces a signal every time an embedded string in the text matches the given regular expression. Examples, problems, and solutions are also presented.},
	language = {en},
	number = {6},
	urldate = {2023-03-05},
	journal = {Communications of the ACM},
	author = {Thompson, Ken},
	month = jun,
	year = {1968},
	pages = {419--422},
	file = {Thompson - 1968 - Programming Techniques Regular expression search .pdf:/Users/joey/Library/Application Support/Zotero/data/storage/7APBE4KL/Thompson - 1968 - Programming Techniques Regular expression search .pdf:application/pdf},
}

@article{shute_focus_2008,
	title = {Focus on {Formative} {Feedback}},
	volume = {78},
	issn = {0034-6543},
	url = {https://doi.org/10.3102/0034654307313795},
	doi = {10.3102/0034654307313795},
	abstract = {This article reviews the corpus of research on feedback, with a focus on formative feedback?defined as information communicated to the learner that is intended to modify his or her thinking or behavior to improve learning. According to researchers, formative feedback should be nonevaluative, supportive, timely, and specific. Formative feedback is usually presented as information to a learner in response to some action on the learner?s part. It comes in a variety of types (e.g., verification of response accuracy, explanation of the correct answer, hints, worked examples) and can be administered at various times during the learning process (e.g., immediately following an answer, after some time has elapsed). Finally, several variables have been shown to interact with formative feedback?s success at promoting learning (e.g., individual characteristics of the learner and aspects of the task). All of these issues are discussed. This review concludes with guidelines for generating formative feedback.},
	number = {1},
	urldate = {2023-03-17},
	journal = {Review of Educational Research},
	author = {Shute, Valerie J.},
	month = mar,
	year = {2008},
	note = {Publisher: American Educational Research Association},
	pages = {153--189},
	file = {SAGE PDF Full Text:/Users/joey/Library/Application Support/Zotero/data/storage/ZJKEZD6A/Shute - 2008 - Focus on Formative Feedback.pdf:application/pdf},
}

@inproceedings{chiodini_expressions_2022,
	address = {New York, NY, USA},
	series = {{SPLASH}-{E} 2022},
	title = {Expressions in {Java}: {Essential}, {Prevalent}, {Neglected}?},
	isbn = {978-1-4503-9900-5},
	shorttitle = {Expressions in {Java}},
	url = {https://doi.org/10.1145/3563767.3568131},
	doi = {10.1145/3563767.3568131},
	abstract = {Expressions are the building blocks of formal languages such as lambda calculus as well as of programming languages that are closely modeled after it. Although expressions are also an important part of programs in languages like Java, that are not primarily functional, teaching practices typically don’t focus as much on expressions. We conduct both a theoretical analysis of the Java language, as well as an empirical analysis of the use of expressions in Java programs by novices, to understand the role expressions play in writing programs. We then proceed by systematically analyzing teaching materials for Java to characterize how they present expressions. Our findings show that expressions are an essential construct in Java, that they are prevalent in student code, but that current textbooks do not introduce expressions as the central, general, and compositional concept they are.},
	urldate = {2023-03-16},
	booktitle = {Proceedings of the 2022 {ACM} {SIGPLAN} {International} {Symposium} on {SPLASH}-{E}},
	publisher = {Association for Computing Machinery},
	author = {Chiodini, Luca and Moreno Santos, Igor and Hauswirth, Matthias},
	year = {2022},
	keywords = {Java, education, Blackbox, textbooks, expressions, Abstract Syntax Tree, grammar, trees},
	pages = {41--51},
	file = {Chiodini et al. - 2022 - Expressions in Java Essential, Prevalent, Neglect.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/GB4KVAS8/Chiodini et al. - 2022 - Expressions in Java Essential, Prevalent, Neglect.pdf:application/pdf},
}

@inproceedings{auvinen_harmful_2015,
	title = {Harmful {Study} {Habits} in {Online} {Learning} {Environments} with {Automatic} {Assessment}},
	doi = {10.1109/LaTiCE.2015.31},
	abstract = {Learning activities are increasingly performed in online learning environments. Automatic assessment is used in many systems to give students immediate and personalized feedback allowing them to solve exercises regardless of time and place. However, this creates new challenges for students because they are required to independently regulate their own learning. Because of the lack of direct guidance, it is easy for students to resort to bad study habits. In this paper, we investigate what kinds of harmful study habits can be observed in online learning environments that utilize automatic assessment. We study data from two computer science courses with programming exercises and algorithm simulation exercises. The results are in line with earlier findings that starting to study near the deadline is linked to inferior performance. This is also observed in a within-subject comparison which suggests that the relationship is causal. Furthermore, signs of trial-and-error problem solving are observed in some students and they are also correlated with inferior performance in the exercises and the exam.},
	booktitle = {2015 {International} {Conference} on {Learning} and {Teaching} in {Computing} and {Engineering}},
	author = {Auvinen, Tapio},
	month = apr,
	year = {2015},
	keywords = {Data models, Programming profession, Data structures, Computational modeling, Algorithm design and analysis, procrastination, educational technology, massed practice, study habits, trial and error},
	pages = {50--57},
	file = {IEEE Xplore Abstract Record:/Users/joey/Library/Application Support/Zotero/data/storage/28TYV26Z/stamp.html:text/html;IEEE Xplore Full Text PDF:/Users/joey/Library/Application Support/Zotero/data/storage/26KKLYX8/Auvinen - 2015 - Harmful Study Habits in Online Learning Environmen.pdf:application/pdf},
}

@book{schumacher_software_1994,
	title = {Software {Solutions} in {C}},
	isbn = {978-0-12-632360-3},
	abstract = {Software Solutions in C contains a diverse collection of flexible and portable solutions to common programming problems. These are tried and true implementations, which can be incorporated into any programs. This guide contains working C and C++ code, along with articles explaining the code. Each article focuses on a specific problem and its solution. The usage explanation of the working solutions should allow for quick implementation of these routines into existing applications. All of the design trade-offs involved in the implementation are explained thoroughly and, within the direct solutions, a wealth of tricks, tips and techniques are included.},
	language = {en},
	publisher = {AP Professional},
	author = {Schumacher, Dale},
	year = {1994},
	note = {Google-Books-ID: Lr\_VAAAACAAJ},
}

@inproceedings{koopman_32-bit_2002,
	address = {Washington, DC, USA},
	title = {32-bit cyclic redundancy codes for {Internet} applications},
	isbn = {978-0-7695-1597-7},
	url = {http://ieeexplore.ieee.org/document/1028931/},
	doi = {10.1109/DSN.2002.1028931},
	abstract = {Standardized 32-bit Cyclic Redundancy Codes provide fewer bits of guaranteed error detection than they could, achieving a Hamming Distance (HD) of only 4 for maximum-length Ethernet messages, whereas HD=6 is possible. Although research has revealed improved codes, exploring the entire design space has previously been computationally intractable, even for special-purpose hardware. Moreover, no CRC polynomial has yet been found that satisfies an emerging need to attain both HD=6 for 12K bit messages and HD=4 for message lengths beyond 64K bits. This paper presents results from the first exhaustive search of the 32-bit CRC design space. Results from previous research are validated and extended to include identifying all polynomials achieving a better HD than the IEEE 802.3 CRC-32 polynomial. A new class of polynomials is identified that provides HD=6 up to nearly 16K bit and HD=4 up to 114K bit message lengths, providing the best achievable design point that maximizes error detection for both legacy and new applications, including potentially iSCSI and application-implemented error checks.},
	language = {en},
	urldate = {2023-04-16},
	booktitle = {Proceedings {International} {Conference} on {Dependable} {Systems} and {Networks}},
	publisher = {IEEE Comput. Soc},
	author = {Koopman, P.},
	year = {2002},
	pages = {459--468},
	file = {Koopman - 2002 - 32-bit cyclic redundancy codes for Internet applic.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/3R95UDAW/Koopman - 2002 - 32-bit cyclic redundancy codes for Internet applic.pdf:application/pdf},
}

@misc{github_inc_2020_2020,
	title = {2020 {GitHub} {Education} {Classroom} {Report}},
	url = {https://education.github.com/classroom-report/2020},
	language = {en},
	urldate = {2023-04-18},
	journal = {2020 GitHub Education Classroom Report},
	author = {{GitHub, Inc.}},
	year = {2020},
	file = {Snapshot:/Users/joey/Library/Application Support/Zotero/data/storage/B6ZEVDKH/2020.html:text/html},
}

@misc{github_inc_github_2023,
	title = {{GitHub} {Actions} {Documentation}},
	url = {https://docs.github.com/en/rest/actions},
	abstract = {Automate, customize, and execute your software development workflows right in your repository with GitHub Actions. You can discover, create, and share actions to perform any job you'd like, including CI/CD, and combine actions in a completely customized workflow.},
	language = {en},
	urldate = {2023-04-18},
	journal = {GitHub Actions Docs},
	author = {{GitHub, Inc.}},
	year = {2023},
	file = {Snapshot:/Users/joey/Library/Application Support/Zotero/data/storage/WEM33RCB/actions.html:text/html},
}

@techreport{hardt_oauth_2012,
	type = {Request for {Comments}},
	title = {The {OAuth} 2.0 {Authorization} {Framework}},
	url = {https://datatracker.ietf.org/doc/rfc6749},
	abstract = {The OAuth 2.0 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf. This specification replaces and obsoletes the OAuth 1.0 protocol described in RFC 5849. [STANDARDS-TRACK]},
	number = {RFC 6749},
	urldate = {2023-05-24},
	institution = {Internet Engineering Task Force},
	author = {Hardt, Dick},
	month = oct,
	year = {2012},
	doi = {10.17487/RFC6749},
	note = {Num Pages: 76},
	file = {Full Text PDF:/Users/joey/Library/Application Support/Zotero/data/storage/SBR8ZYEE/Hardt - 2012 - The OAuth 2.0 Authorization Framework.pdf:application/pdf},
}

@techreport{bradner_key_1997,
	type = {Request for {Comments}},
	title = {Key words for use in {RFCs} to {Indicate} {Requirement} {Levels}},
	url = {https://datatracker.ietf.org/doc/rfc2119},
	abstract = {In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.},
	number = {RFC 2119},
	urldate = {2023-05-24},
	institution = {Internet Engineering Task Force},
	author = {Bradner, Scott O.},
	month = mar,
	year = {1997},
	doi = {10.17487/RFC2119},
	note = {Num Pages: 3},
	file = {Full Text PDF:/Users/joey/Library/Application Support/Zotero/data/storage/AECUQ7V7/Bradner - 1997 - Key words for use in RFCs to Indicate Requirement .pdf:application/pdf},
}

@incollection{parsons_stratified_2017,
	title = {Stratified {Sampling}},
	isbn = {978-1-118-44511-2},
	abstract = {Stratified sampling is a probability sampling method that is implemented in sample surveys. The target population's elements are divided into distinct groups or strata where within each stratum the elements are similar to each other with respect to select characteristics of importance to the survey. Stratification is also used to increase the efficiency of a sample design with respect to survey costs and estimator precision. In this article, the foundations of stratified sampling are discussed in the framework of simple random sampling. Topics include the forming of the strata and optimal sample allocation among the strata. Practical implementation issues for stratified sampling are discussed and include systematic sampling, implicit stratification, and the construction of strata using modern software. The importance of using stratified sampling in practice is demonstrated by its usage in five major large-scale health surveys conducted in the United States and the United Kingdom. For these surveys, details of the stratification and sampling methods are provided. Topics include multistage cluster sampling within strata and the use of systematic and probability proportional to size sampling.},
	booktitle = {Wiley {StatsRef}: {Statistics} {Reference} {Online}},
	publisher = {Wiley Online Library},
	author = {Parsons, Van},
	month = feb,
	year = {2017},
	doi = {10.1002/9781118445112.stat05999.pub2},
}

@article{parr_ll_2011,
	title = {{LL}(*): the foundation of the {ANTLR} parser generator},
	volume = {46},
	issn = {0362-1340},
	shorttitle = {{LL}(*)},
	url = {https://doi.org/10.1145/1993316.1993548},
	doi = {10.1145/1993316.1993548},
	abstract = {Despite the power of Parser Expression Grammars (PEGs) and GLR, parsing is not a solved problem. Adding nondeterminism (parser speculation) to traditional LL and LR parsers can lead to unexpected parse-time behavior and introduces practical issues with error handling, single-step debugging, and side-effecting embedded grammar actions. This paper introduces the LL(*) parsing strategy and an associated grammar analysis algorithm that constructs LL(*) parsing decisions from ANTLR grammars. At parse-time, decisions gracefully throttle up from conventional fixed k{\textgreater}=1 lookahead to arbitrary lookahead and, finally, fail over to backtracking depending on the complexity of the parsing decision and the input symbols. LL(*) parsing strength reaches into the context-sensitive languages, in some cases beyond what GLR and PEGs can express. By statically removing as much speculation as possible, LL(*) provides the expressivity of PEGs while retaining LL's good error handling and unrestricted grammar actions. Widespread use of ANTLR (over 70,000 downloads/year) shows that it is effective for a wide variety of applications.},
	number = {6},
	urldate = {2023-06-05},
	journal = {ACM SIGPLAN Notices},
	author = {Parr, Terence and Fisher, Kathleen},
	month = jun,
	year = {2011},
	keywords = {augmented transition networks, backtracking, context-sensitive parsing, deterministic finite automata, glr, memoization, nondeterministic parsing, peg, semantic predicates, subset construction, syntactic predicates},
	pages = {425--436},
	file = {Parr and Fisher - LL() The Foundation of the ANTLR Parser Generato.pdf:/Users/joey/Library/Application Support/Zotero/data/storage/4E9CLMKH/Parr and Fisher - LL() The Foundation of the ANTLR Parser Generato.pdf:application/pdf},
}

@inproceedings{parsons_parsons_2006,
	address = {AUS},
	series = {{ACE} '06},
	title = {Parson's programming puzzles: a fun and effective learning tool for first programming courses},
	isbn = {978-1-920682-34-7},
	shorttitle = {Parson's programming puzzles},
	abstract = {Mastery of basic syntactic and logical constructs is an essential part of learning to program. Unfortunately, practice exercises for programming basics can be very tedious, making it difficult to motivate students. In this paper we describe Parson's Programming Puzzles, an automated, interactive tool that provides practice with basic programming principles in an entertaining puzzle-like format. Careful design of the items in the puzzles allows the tutor to highlight particular topics and common programming errors. Since each puzzle solution is a complete sample of well-written code, use of the tool exposes students to good programming practice. This paper discusses the motivation of Parson's Programming Puzzles, and gives several examples. We describe the web-based authoring tool used to build the puzzles, and present our plans for future development.},
	urldate = {2023-06-06},
	booktitle = {Proceedings of the 8th {Australasian} {Conference} on {Computing} {Education} - {Volume} 52},
	publisher = {Australian Computer Society, Inc.},
	author = {Parsons, Dale and Haden, Patricia},
	month = jan,
	year = {2006},
	keywords = {interactive teaching tools, teaching introductory programming},
	pages = {157--163},
	file = {Full Text PDF:/Users/joey/Library/Application Support/Zotero/data/storage/LTQI7GN7/Parsons and Haden - 2006 - Parson's programming puzzles a fun and effective .pdf:application/pdf},
}

@misc{docker_inc_docker_2022,
	title = {Docker: {Accelerated}, {Containerized} {Application} {Development}},
	shorttitle = {Docker},
	url = {https://www.docker.com/},
	abstract = {Docker is a platform designed to help developers build, share, and run modern applications. We handle the tedious setup, so you can focus on the code.},
	language = {en-US},
	urldate = {2023-06-06},
	author = {{Docker, Inc.}},
	month = may,
	year = {2022},
	file = {Snapshot:/Users/joey/Library/Application Support/Zotero/data/storage/LYLRC82T/www.docker.com.html:text/html},
}
